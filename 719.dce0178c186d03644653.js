(self.webpackChunk=self.webpackChunk||[]).push([[719],{6168:function(e,t){function r(e,t){for(let r in e)t(e[r],r)}function a(e,t){e.forEach(t)}function n(e,t){if(!e)throw Error(t)}function o(e,t){ve={parent:ve,value:e,template:he(e,"template")||ke(),sidRoot:he(e,"sidRoot")||ve&&ve.sidRoot};try{return t()}finally{ve=me(ve)}}function l({node:e=[],from:t,source:r,parent:n=t||r,to:o,target:l,child:s=o||l,scope:i={},meta:f={},family:c={type:"regular"},regional:u}={}){let d=Se(n),p=Se(c.links),m=Se(c.owners),g=[];a(e,(e=>e&&R(g,e)));let h={id:H(),seq:g,next:Se(s),meta:f,scope:i,family:{type:c.type||"crosslink",links:p,owners:m}};return a(p,(e=>R(fe(e),h))),a(m,(e=>R(ce(e),h))),a(d,(e=>R(e.next,h))),u&&ve&&be(de(ve),[h]),h}function s(e,t,r){let n=Re,o=null,l=Oe;if(e.target&&(t=e.params,r=e.defer,n="page"in e?e.page:n,e.stack&&(o=e.stack),l=ge(e)||l,e=e.target),l&&Oe&&l!==Oe&&(Oe=null),Array.isArray(e))for(let r=0;r<e.length;r++)Ie("pure",n,ie(e[r]),o,t[r],l);else Ie("pure",n,ie(e),o,t,l);if(r&&!Fe)return;let s,i,f,c,u,d,p={isRoot:Fe,currentPage:Re,scope:Oe,isWatch:De};Fe=0;e:for(;c=Ae();){let{idx:e,stack:t,type:r}=c;f=t.node,Re=u=t.page,Oe=ge(t),u?d=u.reg:Oe&&(d=Oe.reg);let n=!!u,o=!!Oe,l={fail:0,scope:f.scope};s=i=0;for(let a=e;a<f.seq.length&&!s;a++){let c=f.seq[a];if(c.order){let{priority:n,barrierID:o}=c.order,l=o?u?`${u.fullID}_${o}`:o:0;if(a!==e||r!==n){o?$e.has(l)||($e.add(l),Ne(a,t,n,o)):Ne(a,t,n);continue e}o&&$e.delete(l)}switch(c.type){case"mov":{let e,r=c.data;switch(r.from){case C:e=de(t);break;case"a":case"b":e=t[r.from];break;case"value":e=r.store;break;case"store":if(d&&!d[r.store.id])if(n){let e=Ve(u,r.store.id);t.page=u=e,e?d=e.reg:o?(Pe(Oe,r.store,0,1,r.softRead),d=Oe.reg):d=void 0}else o&&Pe(Oe,r.store,0,1,r.softRead);e=ae(d&&d[r.store.id]||r.store)}switch(r.to){case C:t.value=e;break;case"a":case"b":t[r.to]=e;break;case"store":Ee(u,Oe,f,r.target).current=e}break}case"compute":let e=c.data;if(e.fn){De="watch"===he(f,"op");let r=e.safe?(0,e.fn)(de(t),l.scope,t):Be(l,e.fn,t);e.filter?i=!r:t.value=r,De=p.isWatch}}s=l.fail||i}if(!s){let e=de(t);a(f.next,(r=>{Ie("child",u,r,t,e,ge(t))}));let r=ge(t);if(r){he(f,"needFxCounter")&&Ie("child",u,r.fxCount,t,e,r),he(f,"storeChange")&&Ie("child",u,r.storeChange,t,e,r);let n=r.additionalLinks[f.id];n&&a(n,(a=>{Ie("child",u,a,t,e,r)}))}}}Fe=p.isRoot,Re=p.currentPage,Oe=ge(p)}function i(e,t="combine"){let a=t+"(",n="",o=0;return r(e,(e=>{o<25&&(null!=e&&(a+=n,a+=j(e)?Le(e).fullName:e.toString()),o+=1,n=", ")})),a+")"}function f(e,t){let r,a,n=e;if(t){let n=Le(t);0===e.length?(r=n.path,a=n.fullName):(r=n.path.concat([e]),a=0===n.fullName.length?e:n.fullName+"/"+e)}else r=0===e.length?[]:[e],a=e;return{shortName:n,fullName:a,path:r}}function c(e,t){let r=t?e:e[0];return P(r),r.and&&(e=r.and),[e,r.or]}function u(e,...t){let r=ke();if(r){let a=r.handlers[e];if(a)return a(r,...t)}}function d(e,t){let r=(e,...t)=>(_(!he(r,"derived"),"call of derived event","createEvent"),Re?((e,t,r,a)=>{let n=Re,o=null;if(t)for(o=Re;o&&o.template!==t;)o=me(o);ze(o);let l=e.create(r,a);return ze(n),l})(r,a,e,t):r.create(e,t)),a=ke();return Object.assign(r,{graphite:l({meta:Ye("event",r,e,t),regional:1}),create:e=>(s({target:r,params:e,scope:Oe}),e),watch:e=>Qe(r,e),map:e=>et(r,x,e,[Q({fn:se})]),filter:e=>et(r,"filter",e.fn?e:e.fn,[X({fn:se})]),filterMap:e=>et(r,"filterMap",e,[Q({fn:se}),Z((e=>!E(e)),1)]),prepend(e){let t=d("* → "+r.shortName,{parent:me(r)});return u("eventPrepend",ie(t)),Ke(t,r,[Q({fn:se})],"prepend",e),Xe(r,t),t}})}function p(e,t){let r=re(e),o=Ze("updates");u("storeBase",r);let i=r.id,f={subscribers:new Map,updates:o,defaultState:e,stateRef:r,getState(){let e,t=r;if(Re){let t=Re;for(;t&&!t.reg[i];)t=me(t);t&&(e=t)}return!e&&Oe&&(Pe(Oe,r,1),e=Oe),e&&(t=e.reg[i]),ae(t)},setState:e=>s({target:f,params:e,defer:1,scope:Oe}),reset:(...e)=>(a(e,(e=>f.on(e,(()=>f.defaultState)))),f),on:(e,t)=>(L(e,".on","first argument"),_(!he(f,"derived"),".on in derived store","createStore"),a(Array.isArray(e)?e:[e],(e=>{f.off(e),pe(f).set(e,Je(tt(e,f,"on",le,t)))})),f),off(e){let t=pe(f).get(e);return t&&(t(),pe(f).delete(e)),f},map(e,t){let a,n;z(e)&&(a=e,e=e.fn),_(E(t),"second argument of store.map","updateFilter");let o=f.getState();ke()?n=null:E(o)||(n=e(o,t));let l=p(n,{name:`${f.shortName} → *`,derived:1,and:a}),s=tt(f,l,x,oe,e);return ne(ue(l),{type:x,fn:e,from:r}),ue(l).noInit=1,u("storeMap",r,s),l},watch(e,t){if(!t||!j(e)){let t=Qe(f,e);return u("storeWatch",r,e)||e(f.getState()),t}return n(V(t),"second argument should be a function"),e.watch((e=>t(f.getState(),e)))}},c=Ye("store",f,t),d=f.defaultConfig.updateFilter;f.graphite=l({scope:{state:r,fn:d},node:[Z(((e,t,a)=>(a.scope&&!a.scope.reg[r.id]&&(a.b=1),e))),ee(r),Z(((e,t,{a:r,b:a})=>!E(e)&&(e!==r||a)),1),d&&X({fn:oe}),K({from:C,target:r})],child:o,meta:c,regional:1});let m=he(f,"sid");return m&&("ignore"!==he(f,"serialize")&&ye(f,"storeChange",1),r.sid=m),n(he(f,"derived")||!E(e),"current state can't be undefined, use null instead"),be(f,[o]),f}function m(...e){let t,r,a;[e,a]=c(e);let o,l,s,i=e[e.length-1];if(V(i)?(r=e.slice(0,-1),t=i):r=e,1===r.length){let e=r[0];A(e)||(o=e,l=1)}if(!l&&(o=r,t)){s=1;let e=t;t=t=>e(...t)}return n(z(o),"shape should be an object"),rt(Array.isArray(o),!s,o,a,t)}function g(){let e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e.req.catch((()=>{})),e}function h(e,t){let r=d(V(e)?{handler:e}:e,t),a=ie(r);ye(a,"op",r.kind="effect"),r.use=e=>(n(V(e),".use argument should be a function"),m.scope.handler=e,r),r.use.getCurrent=()=>m.scope.handler;let o=r.finally=Ze("finally"),i=r.done=o.filterMap({named:"done",fn({status:e,params:t,result:r}){if("done"===e)return{params:t,result:r}}}),f=r.fail=o.filterMap({named:"fail",fn({status:e,params:t,error:r}){if("fail"===e)return{params:t,error:r}}}),c=r.doneData=i.map({named:"doneData",fn:({result:e})=>e}),u=r.failData=f.map({named:"failData",fn:({error:e})=>e}),m=l({scope:{handlerId:he(a,"sid"),handler:r.defaultConfig.handler||(()=>n(0,`no handler used in ${r.getType()}`))},node:[Z(((e,t,r)=>{let a=t,n=a.handler;if(ge(r)){let e=ge(r).handlers[a.handlerId];e&&(n=e)}return e.handler=n,e})),Z((({params:e,req:t,handler:r,args:a=[e]},n,l)=>{let s=nt(e,t,1,o,l),i=nt(e,t,0,o,l),[f,c]=at(r,i,a);f&&(z(c)&&V(c.then)?c.then(s,i):s(c))}),0,1)],meta:{op:"fx",fx:"runner"}});a.scope.runner=m,R(a.seq,Z(((e,{runner:t},r)=>{let a=me(r)?{params:e,req:{rs(e){},rj(e){}}}:e;return s({target:t,params:a,defer:1,scope:ge(r)}),a.params}),0,1)),r.create=e=>{let t=g(),a={params:e,req:t};if(Oe){if(!De){let e=Oe;t.req.finally((()=>{_e(e)})).catch((()=>{}))}s({target:r,params:a,scope:Oe})}else s(r,a);return t.req};let h=r.inFlight=p(0,{named:"inFlight"}).on(r,(e=>e+1)).on(o,(e=>e-1));ye(o,"needFxCounter","dec"),ye(r,"needFxCounter",1);let y=r.pending=h.map({fn:e=>e>0,named:"pending"});return be(r,[o,i,f,c,u,y,h]),r}function y(e,t){let r=d(t||i(e,"merge"));return L(e,"merge","first argument"),Ke(e,r,[],"merge"),r}function b(e,t){let r=0;return a(lt,(a=>{a in e&&(n(null!=e[a],st(t,a)),r=1)})),r}function v(...e){let t,r,a,[[n,o,s],i]=c(e),f=1;E(o)&&z(n)&&b(n,"sample")&&(o=n.clock,s=n.fn,f=!n.greedy,t=n.target,r=n.name,a=n.sid,n=n.source),[n,o]=it(n,o,"sample"),E(o)&&(o=n),L(o,"sample","clock"),i||r||(r=n.shortName);let m=!!t;if(t||(A(n)&&A(o)?t=p(s?s(ae(ue(n)),ae(ue(o))):ae(ue(n)),{name:r,sid:a,or:i}):(t=d(r,i),u("sampleTarget",ie(t)))),A(n)){let e=ue(n);be(n,[Ke(o,t,[u("sampleSourceLoader"),ee(e,!s,f),s&&Q({fn:le}),u("sampleSourceUpward",m)],"sample",s)]),u("sampleStoreSource",e)}else{let e=re(0),r=re(),a=re();u("sampleNonStoreSource",e,r,a),l({parent:n,node:[K({from:C,target:r}),K({from:"value",store:1,target:e})],family:{owners:[n,t,o],links:t},meta:{op:"sample"},regional:1}),be(n,[Ke(o,t,[u("sampleSourceLoader"),K({from:C,target:a}),ee(e,1),Z((e=>e),1),ee(r,1,f),ee(a),s&&Q({fn:oe}),u("sampleSourceUpward",m)],"sample",s)])}return t}function k(e,t){let r=[];!function e(n){F(r,n)||(R(r,n),"store"===he(n,"op")&&he(n,"sid")&&t(n,he(n,"sid")),a(n.next,e),a(fe(n),e),a(ce(n),e))}(e)}function w(e,t){if(Array.isArray(e)&&(e=new Map(e)),e instanceof Map){let r={};return a(e,((e,a)=>{n(j(a),"Map key should be a unit"),t&&t(a,e),n(a.sid,"unit should have a sid"),n(!(a.sid in r),"duplicate sid found"),r[a.sid]=e})),r}return e}Object.defineProperty(t,"__esModule",{value:1});let S="undefined"!=typeof Symbol&&Symbol.observable||"@@observable",x="map",C="stack",j=e=>(V(e)||z(e))&&"kind"in e;const M=e=>t=>j(t)&&t.kind===e;let A=M("store"),I=M("event"),N=M("effect"),q=M("domain"),$=M("scope");var O={__proto__:null,unit:j,store:A,event:I,effect:N,domain:q,scope:$};let F=(e,t)=>e.includes(t),D=(e,t)=>{let r=e.indexOf(t);-1!==r&&e.splice(r,1)},R=(e,t)=>e.push(t),_=(e,t,r)=>!e&&console.error(`${t} is deprecated, use ${r} instead`),z=e=>"object"==typeof e&&null!==e,V=e=>"function"==typeof e,E=e=>void 0===e,P=e=>n(z(e)||V(e),"expect first argument be an object");const B=(e,t,r,a)=>n(!(!z(e)&&!V(e)||!("family"in e)&&!("graphite"in e)),`${t}: expect ${r} to be a unit (store, event or effect)${a}`);let L=(e,t,r)=>{Array.isArray(e)?a(e,((e,a)=>B(e,t,`${a} item of ${r}`,""))):B(e,t,r," or array of units")};const T=()=>{let e=0;return()=>""+ ++e};let W=T(),U=T(),H=T();const G=(e,t,r,a)=>{let n={id:U(),type:e,data:t};return r&&(n.order={priority:r},a&&(n.order.barrierID=++J)),n};let J=0,K=({from:e="store",store:t,target:r,to:a=(r?"store":C),batch:n,priority:o})=>G("mov",{from:e,store:t,to:a,target:r},o,n),Q=({fn:e,batch:t,priority:r,safe:a=0,filter:n=0})=>G("compute",{fn:e,safe:a,filter:n},r,t),X=({fn:e})=>Q({fn:e,filter:1}),Y=({fn:e})=>Q({fn:e,priority:"effect"}),Z=(e,t,r)=>Q({fn:e,safe:1,filter:t,priority:r&&"effect"}),ee=(e,t,r)=>K({store:e,to:t?C:"a",priority:r&&"sampler",batch:1}),te={mov:K,compute:Q,filter:X,run:Y},re=e=>({id:U(),current:e}),ae=({current:e})=>e,ne=(e,t)=>{e.before||(e.before=[]),R(e.before,t)},oe=(e,{fn:t},{a:r})=>t(e,r),le=(e,{fn:t},{a:r})=>t(r,e),se=(e,{fn:t})=>t(e),ie=e=>e.graphite||e,fe=e=>e.family.owners,ce=e=>e.family.links,ue=e=>e.stateRef,de=e=>e.value,pe=e=>e.subscribers,me=e=>e.parent,ge=e=>e.scope,he=(e,t)=>ie(e).meta[t],ye=(e,t,r)=>ie(e).meta[t]=r,be=(e,t)=>{let r=ie(e);a(t,(e=>{let t=ie(e);"domain"!==r.family.type&&(t.family.type="crosslink"),R(fe(t),r),R(ce(r),t)}))},ve=null,ke=()=>ve&&ve.template,we=e=>(e&&ve&&ve.sidRoot&&(e=`${ve.sidRoot}|${e}`),e);const Se=(e=[])=>(Array.isArray(e)?e:[e]).flat().map(ie);let xe=null;const Ce=(e,t)=>{if(!e)return t;if(!t)return e;let r,a=e.v.type===t.v.type;return(a&&e.v.id>t.v.id||!a&&"sampler"===e.v.type)&&(r=e,e=t,t=r),r=Ce(e.r,t),e.r=e.l,e.l=r,e},je=[];let Me=0;for(;Me<5;)R(je,{first:null,last:null,size:0}),Me+=1;const Ae=()=>{for(let e=0;e<5;e++){let t=je[e];if(t.size>0){if(2===e||3===e){t.size-=1;let e=xe.v;return xe=Ce(xe.l,xe.r),e}1===t.size&&(t.last=null);let r=t.first;return t.first=r.r,t.size-=1,r.v}}},Ie=(e,t,r,a,n,o)=>Ne(0,{a:null,b:null,node:r,parent:a,value:n,page:t,scope:o},e),Ne=(e,t,r,a=0)=>{let n=qe(r),o=je[n],l={v:{idx:e,stack:t,type:r,id:a},l:null,r:null};2===n||3===n?xe=Ce(xe,l):(0===o.size?o.first=l:o.last.r=l,o.last=l),o.size+=1},qe=e=>{switch(e){case"child":return 0;case"pure":return 1;case"barrier":return 2;case"sampler":return 3;case"effect":return 4;default:return-1}},$e=new Set;let Oe,Fe=1,De=0,Re=null,_e=e=>{Oe=e},ze=e=>{Re=e};const Ve=(e,t)=>{if(e){for(;e&&!e.reg[t];)e=me(e);if(e)return e}return null};let Ee=(e,t,r,a,n)=>{let o=Ve(e,a.id);return o?o.reg[a.id]:t?(Pe(t,a,n),t.reg[a.id]):a},Pe=(e,t,r,n,o)=>{let l=e.reg,s=t.sid;if(l[t.id])return;let i={id:t.id,current:t.current};if(s&&s in e.sidValuesMap&&!(s in e.sidIdMap))i.current=e.sidValuesMap[s];else if(t.before&&!o){let o=0,s=r||!t.noInit||n;a(t.before,(t=>{switch(t.type){case x:{let a=t.from;if(a||t.fn){a&&Pe(e,a,r,n);let o=a&&l[a.id].current;s&&(i.current=t.fn?t.fn(o):o)}break}case"field":o||(o=1,i.current=Array.isArray(i.current)?[...i.current]:{...i.current}),Pe(e,t.from,r,n),s&&(i.current[t.field]=l[l[t.from.id].id].current)}}))}s&&(e.sidIdMap[s]=t.id),l[t.id]=i};const Be=(e,t,r)=>{try{return t(de(r),e.scope,r)}catch(t){console.error(t),e.fail=1}},Le=e=>e.compositeName;let Te=(e,t={})=>(z(e)&&(Te(e.or,t),r(e,((e,r)=>{E(e)||"or"===r||"and"===r||(t[r]=e)})),Te(e.and,t)),t);const We=(e,t)=>{D(e.next,t),D(fe(e),t),D(ce(e),t)},Ue=(e,t,r)=>{let a;e.next.length=0,e.seq.length=0,e.scope=null;let n=ce(e);for(;a=n.pop();)We(a,e),(t||r&&"sample"!==he(e,"op")||"crosslink"===a.family.type)&&Ue(a,t,"on"!==he(a,"op")&&r);for(n=fe(e);a=n.pop();)We(a,e),r&&"crosslink"===a.family.type&&Ue(a,t,"on"!==he(a,"op")&&r)},He=e=>e.clear();let Ge=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),A(e))He(pe(e));else if(q(e)){r=1;let t=e.history;He(t.events),He(t.effects),He(t.stores),He(t.domains)}Ue(ie(e),!!t,r)},Je=e=>{let t=()=>Ge(e);return t.unsubscribe=t,t},Ke=(e,t,r,a,n)=>l({node:r,parent:e,child:t,scope:{fn:n},meta:{op:a},family:{owners:[e,t],links:t},regional:1}),Qe=(e,t)=>(n(V(t),".watch argument should be a function"),Je(l({scope:{fn:t},node:[Y({fn:se})],parent:e,meta:{op:"watch"},family:{owners:e},regional:1}))),Xe=(e,t,r="event")=>{me(e)&&me(e).hooks[r](t)},Ye=(e,t,r,a)=>{let n="domain"===e,o=W(),l=Te({or:a,and:"string"==typeof r?{name:r}:r}),{parent:s=null,sid:i=null,named:c=null}=l,u=c||l.name||(n?"":o),d=f(u,s),p={op:t.kind=e,name:t.shortName=u,sid:t.sid=we(i),named:c,unitId:t.id=o,serialize:l.serialize,derived:l.derived};if(t.parent=s,t.compositeName=d,t.defaultConfig=l,t.thru=e=>(_(0,"thru","js pipe"),e(t)),t.getType=()=>d.fullName,!n){t.subscribe=e=>(P(e),t.watch(V(e)?e:t=>e.next&&e.next(t))),t[S]=()=>t;let e=ke();e&&(p.nativeTemplate=e)}return p},Ze=e=>d({named:e});const et=(e,t,r,a)=>{let n;z(r)&&(n=r,r=r.fn);let o=d({name:`${e.shortName} → *`,derived:1,and:n});return Ke(e,o,a,t,r),o},tt=(e,t,r,a,n)=>{let o=ue(t),l=ee(o);r===x&&(l.data.softRead=1);let s=[l,Q({fn:a})];return u("storeOnMap",o,s,A(e)&&ue(e)),Ke(e,t,s,r,n)},rt=(e,t,a,o,l)=>{let s=e?e=>e.slice():e=>({...e}),f=e?[]:{},c=s(f),d=re(c),m=re(1);d.type=e?"list":"shape",d.noInit=1,u("combineBase",d,m);let g=p(c,{name:i(a),derived:1,and:o}),h=ue(g);h.noInit=1,ye(g,"isCombine",1);let y=[Z(((e,t,r)=>(r.scope&&!r.scope.reg[d.id]&&(r.c=1),e))),ee(d),K({store:m,to:"b"}),Z(((e,{key:r},a)=>{if(a.c||e!==a.a[r])return t&&a.b&&(a.a=s(a.a)),a.a[r]=e,1}),1),K({from:"a",target:d}),K({from:"value",store:0,target:m}),K({from:"value",store:1,target:m,priority:"barrier",batch:1}),ee(d,1),l&&Q({fn:se})];return r(a,((e,t)=>{if(!A(e))return n(!j(e)&&!E(e),`combine expects a store in a field ${t}`),void(c[t]=f[t]=e);f[t]=e.defaultState,c[t]=e.getState();let r=Ke(e,g,y,"combine",l);r.scope.key=t;let a=ue(e);ne(d,{type:"field",field:t,from:a}),u("combineField",a,r)})),g.defaultShape=a,ne(h,{type:x,from:d,fn:l}),ke()||(g.defaultState=l?h.current=l(c):f),g};let at=(e,t,r)=>{try{return[1,e(...r)]}catch(e){return t(e),[0,null]}},nt=(e,t,r,a,n)=>o=>s({target:[a,ot],params:[r?{status:"done",params:e,result:o}:{status:"fail",params:e,error:o},{value:o,fn:r?t.rs:t.rj}],defer:1,page:n.page,scope:ge(n)}),ot=l({node:[Y({fn:({fn:e,value:t})=>e(t)})],meta:{op:"fx",fx:"sidechain"}});const lt=["source","clock","target"],st=(e,t)=>e+`: ${t} should be defined`;let it=(e,t,r)=>(n(!E(e)||!E(t),st(r,"either source or clock")),E(e)?(L(t,r,"clock"),Array.isArray(t)&&(t=y(t)),e=t):j(e)||(e=m(e)),[e,t]);const ft=(e,t,r,a)=>{let n=e[t];n&&s({target:n,params:Array.isArray(n)?n.map((()=>r)):r,defer:1,stack:a})};t.allSettled=(e,{scope:t,params:r})=>{if(!j(e))return Promise.reject(Error("first argument should be unit"));let a=g();a.parentFork=Oe;let{fxCount:n}=t;R(n.scope.defers,a);let o=[e],l=[];return R(l,N(e)?{params:r,req:{rs(e){a.value={status:"done",value:e}},rj(e){a.value={status:"fail",value:e}}}}:r),R(o,n),R(l,null),s({target:o,params:l,scope:t}),a.req},t.attach=e=>{let t;[e,t]=c(e,1);let{source:r,effect:a,mapParams:n}=e,o=h(e,t);ye(o,"attached",1);let l,{runner:i}=ie(o).scope,f=Z(((e,t,a)=>{let l,{params:i,req:f,handler:c}=e,u=o.finally,d=nt(i,f,0,u,a),p=a.a,m=N(c),g=1;if(n?[g,l]=at(n,d,[i,p]):l=r&&m?p:i,g){if(!m)return e.args=[p,l],1;s({target:c,params:{params:l,req:{rs:nt(i,f,1,u,a),rj:d}},page:a.page,defer:1})}}),1,1);if(r){let e;A(r)?(e=r,be(e,[o])):(e=m(r),be(o,[e])),l=[ee(ue(e)),f]}else l=[f];return i.seq.splice(1,0,...l),o.use(a),Xe(a,o,"effect"),o},t.clearNode=Ge,t.combine=m,t.createApi=(...e)=>{let[[t,a],n]=c(e),o={};return r(a,((e,r)=>{let a=o[r]=d(r,{parent:me(t),config:n});t.on(a,e),Xe(t,a)})),o},t.createDomain=function e(t,n){let o=l({family:{type:"domain"},regional:1}),i={history:{},graphite:o,hooks:{}};o.meta=Ye("domain",i,t,n),r({Event:d,Effect:h,Store:p,Domain:e},((e,t)=>{let r=t.toLowerCase(),n=Ze(`on${t}`);i.hooks[r]=n;let o=new Set;i.history[`${r}s`]=o,n.create=e=>(s(n,e),e),R(ie(n).seq,Z(((e,t,r)=>(r.scope=null,e)))),n.watch((e=>{be(i,[e]),o.add(e),e.ownerSet||(e.ownerSet=o),me(e)||(e.parent=i)})),be(i,[n]),i[`onCreate${t}`]=e=>(a(o,e),n.watch(e)),i[`create${t}`]=i[r]=(t,r)=>n(e(t,{parent:i,or:r}))}));let f=me(i);return f&&r(i.hooks,((e,t)=>Ke(e,f.hooks[t]))),i},t.createEffect=h,t.createEvent=d,t.createNode=l,t.createStore=p,t.createStoreObject=(...e)=>(_(0,"createStoreObject","combine"),m(...e)),t.fork=(e,t)=>{let r,o=e;q(e)&&(r=e,o=t);let s=(e=>{let t=l({scope:{defers:[],inFlight:0,fxID:0},node:[Z(((e,t,r)=>{me(r)?"dec"===he(me(r).node,"needFxCounter")?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1})),Q({priority:"sampler",batch:1}),Z(((e,t)=>{let{defers:r,fxID:n}=t;t.inFlight>0||0===r.length||Promise.resolve().then((()=>{t.fxID===n&&a(r.splice(0,r.length),(e=>{_e(e.parentFork),e.rs(e.value)}))}))}),0,1)]}),r=l({node:[Z(((e,t,r)=>{let a=me(r);if(a&&me(a)){let t=a.node;if(!he(t,"isCombine")||"combine"!==he(me(a).node,"op")){let a=ge(r),n=t.scope.state.id,o=he(t,"sid");a.sidIdMap[o]=n,a.sidValuesMap[o]=e}}}))]}),n={cloneOf:e,reg:{},sidValuesMap:{},sidIdMap:{},getState(e){if("current"in e)return Ee(Re,n,null,e).current;let t=ie(e);return Ee(Re,n,t,t.scope.state,1).current},kind:"scope",graphite:l({family:{type:"domain",links:[t,r]},meta:{unit:"fork"},scope:{forkInFlightCounter:t}}),additionalLinks:{},handlers:{},fxCount:t,storeChange:r};return n})(r);if(o){if(o.values){let e=w(o.values,(e=>n(A(e),"Values map can contain only stores as keys")));Object.assign(s.sidValuesMap,e)}o.handlers&&(s.handlers=w(o.handlers,(e=>n(N(e),"Handlers map can contain only effects as keys"))))}return s},t.forward=e=>{let[{from:t,to:r},a]=c(e,1);return L(t,"forward",'"from"'),L(r,"forward",'"to"'),Je(l({parent:t,child:r,meta:{op:"forward",config:a},family:{},regional:1}))},t.fromObservable=e=>{P(e);let t=S in e?e[S]():e;n(t.subscribe,"expect observable to have .subscribe");let r=d(),a=Je(r);return t.subscribe({next:r,error:a,complete:a}),r},t.guard=(...e)=>{let t="guard",[[r,a],o]=c(e);a||(a=r,r=a.source),b(a,t);let{filter:s,greedy:i,clock:f,name:u=(o&&o.name?o.name:t)}=a,p=a.target||d(u,o),m=j(s);return[r,f]=it(r,f,t),f&&(L(f,t,"clock"),r=v({source:r,clock:f,greedy:i,fn:m?null:(e,t)=>({source:e,clock:t})})),L(p,t,"target"),m?v({source:s,clock:r,target:l({node:[Z((({guard:e})=>e),1),Z((({data:e})=>e))],child:p,meta:{op:t},family:{owners:[r,s,p,...[].concat(f||[])],links:p},regional:1}),fn:(e,t)=>({guard:e,data:t}),greedy:i,name:u}):(n(V(s),"`filter` should be function or unit"),Ke(r,p,f?[X({fn:({source:e,clock:t},{fn:r})=>r(e,t)}),Z((({source:e})=>e))]:[X({fn:se})],t,s)),p},t.hydrate=(e,{values:t})=>{n(z(t),"values property should be an object");let r,a,o,l=w(t),i=Object.getOwnPropertyNames(l),f=[],c=[];$(e)?(r=e,o=1,n(r.cloneOf,"scope should be created from domain"),a=ie(r.cloneOf)):q(e)?a=ie(e):n(0,"first argument of hydrate should be domain or scope"),k(a,((e,t)=>{F(i,t)&&(R(f,e),R(c,l[t]))})),s({target:f,params:c,scope:r}),o&&Object.assign(r.sidValuesMap,l)},t.is=O,t.launch=s,t.merge=y,t.restore=(e,t,a)=>{if(A(e))return e;if(I(e)||N(e)){let r=me(e),n=p(t,{parent:r,name:e.shortName,and:a});return Ke(N(e)?e.doneData:e,n),r&&r.hooks.store(n),n}let n=Array.isArray(e)?[]:{};return r(e,((e,t)=>n[t]=A(e)?e:p(e,{name:t}))),n},t.sample=v,t.scopeBind=(e,{scope:t}={})=>{n(t||Oe,"scopeBind cannot be called outside of forked .watch");let r=t||Oe;return N(e)?t=>{let a=g();return s({target:e,params:{params:t,req:a},scope:r}),a.req}:t=>(s({target:e,params:t,scope:r}),t)},t.serialize=(e,t={})=>{let a=t.ignore?t.ignore.map((({sid:e})=>e)):[],o={};return r(e.sidValuesMap,((t,r)=>{if(F(a,r))return;let n=e.sidIdMap[r];o[r]=n&&n in e.reg?e.reg[n].current:t})),"onlyChanges"in t&&!t.onlyChanges&&(n(e.cloneOf,"scope should be created from domain"),k(ie(e.cloneOf),((t,r)=>{r in o||F(a,r)||he(t,"isCombine")||"ignore"===he(t,"serialize")||(o[r]=e.getState(t))}))),o},t.setStoreName=(e,t)=>{e.shortName=t,Object.assign(Le(e),f(t,me(e)))},t.split=(...e)=>{let t,[[a,o],s]=c(e),i=!o;i&&(t=a.cases,o=a.match,a=a.source);let f=A(o),p=!j(o)&&V(o),m=!f&&!p&&z(o);t||(t={}),i||(n(m,"match should be an object"),r(o,((e,r)=>t[r]=d(s))),t.__=d(s));let g,h=new Set([].concat(a,Object.values(t))),y=Object.keys(f||p?t:o);if(f||p)f&&h.add(o),g=[f&&ee(ue(o),0,1),Q({safe:f,filter:1,fn(e,t,r){let a=String(f?r.a:o(e));ft(t,F(y,a)?a:"__",e,r)}})];else if(m){let e=re({});e.type="shape";let t,a=[];r(o,((r,n)=>{if(j(r)){t=1,R(a,n),h.add(r);let o=Ke(r,[],[ee(e),Z(((e,t,{a:r})=>r[n]=e))]);if(A(r)){e.current[n]=r.getState();let t=ue(r);ne(e,{from:t,field:n,type:"field"}),u("splitMatchStore",t,o)}}})),t&&u("splitBase",e),g=[t&&ee(e,0,1),X({fn(e,t,r){for(let n=0;n<y.length;n++){let l=y[n];if(F(a,l)?r.a[l]:o[l](e))return void ft(t,l,e,r)}ft(t,"__",e,r)}})]}else n(0,"expect match to be unit, function or object");if(l({meta:{op:"split"},parent:a,scope:t,node:g,family:{owners:Array.from(h)},regional:1}),!i)return t},t.step=te,t.version="22.0.6",t.withFactory=({sid:e,name:t,loc:r,method:a,fn:n})=>o(l({meta:{sidRoot:we(e),name:t,loc:r,method:a}}),n),t.withRegion=o},6887:function(e){const t=(e,r,a={})=>("object"!=typeof e||null===e||(e.config&&t(e.config,r,a),function(e,t,r){r.filter((t=>void 0!==e[t])).forEach((r=>{t[r]=e[r]}))}(e,a,r),e.ɔ&&t(e.ɔ,r,a)),a);e.exports={readConfig:t}},3719:function(e,t,r){const{createStore:a}=r(6168),{readConfig:n}=r(6887);e.exports={status:function(e){const{sid:t,name:r,loc:o,effect:l,defaultValue:s="initial"}=n(e,["sid","name","loc","effect","defaultValue"]),i=a(s,{sid:t,loc:o,name:r});return i.on(l,(()=>"pending")).on(l.done,(()=>"done")).on(l.fail,(()=>"fail")),i}}}}]);